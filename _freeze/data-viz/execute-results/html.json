{
  "hash": "99bb56d03025fd5c293c22d2732b33c6",
  "result": {
    "engine": "jupyter",
    "markdown": "# Data Viz with Matplot \n\nIt is time to learn the grammar of matplot. Since it is the most popular library and you are going to use data viz a fair amount\n\n## Initializing a plot\n\n::: {#d997460f .cell execution_count=1}\n``` {.python .cell-code}\nimport polars as pl\nimport matplotlib.pyplot as plt \nfrom palmerpenguins import load_penguins\n\n# Load dataset into a Polars DataFrame\npenguins = pl.from_pandas(load_penguins()).drop_nulls()\n```\n:::\n\n\nThe basics of matplot are kind of like ggplot just reshuffled a little bit. To initialize a plot we first create an object. \n\n::: {#3a43b73d .cell execution_count=2}\n``` {.python .cell-code}\nfig,ax = plt.subplots(figsize = (6,6), subplot_kw = {'aspect':1})\n\n```\n\n::: {.cell-output .cell-output-display}\n![](data-viz_files/figure-html/cell-3-output-1.png){width=504 height=490}\n:::\n:::\n\n\nSo in a matplot fig we have control over the axis and what goes in the figure. The figure parts control the actual plotting of the data similar to geometries in ggplot. We initialize the plot with an aspect ratio of 6 inches wide by 6 inches tall.  There are some finer points on the axis but basically we have control over the traditional x and y axis. However, matplot thinks of the the major grid and minor grids, and major labels and minor labels as axis as well. The axis also control the projections of the plot. So if we wanted a polor projection we could do \n\n::: {#f0bed1d8 .cell execution_count=3}\n``` {.python .cell-code}\nfig,ax = plt.subplots(figsize = (12, 6),subplot_kw = {'projection': 'polar', 'aspect': 1})\n```\n\n::: {.cell-output .cell-output-display}\n![](data-viz_files/figure-html/cell-4-output-1.png){width=524 height=513}\n:::\n:::\n\n\nWhich is pretty straight forward. There are some nuances within this but we are just going to keep it pushing. \n\n\n\n\n## Adding geometries \n\nThe next step is to start adding things so we are just going to initialize a new plot. We kinds of just add things with a dot instead of a `+` so lets make a simple scatter plot. \n\n::: {#cd7ee58c .cell execution_count=4}\n``` {.python .cell-code}\nfig,ax = plt.subplots(figsize = (6,6))\n\nplt.scatter(x = penguins['bill_length_mm'], y = penguins['body_mass_g'])\n\n```\n\n::: {.cell-output .cell-output-display}\n![](data-viz_files/figure-html/cell-5-output-1.png){width=509 height=485}\n:::\n:::\n\n\nMatplot is a little bit dumber than `ggplot` meaning that it will just do exactly what you tell it. So instead of putting basic labels on the x and y axis like ggplot it will just plot the data. So if we wanted to add labels to the axis than we need to add the labels \n\n::: {#0e48cbad .cell execution_count=5}\n``` {.python .cell-code}\nplt.xlabel('Bill Depth(mm)')\n\nplt.ylabel('Body Mass (g)')\n\nplt.close()\n```\n:::\n\n\nWe can also add more geometries like this \n\n::: {#b97d9293 .cell execution_count=6}\n``` {.python .cell-code}\nimport numpy as np\nfrom statsmodels.nonparametric.smoothers_lowess import lowess\n\nx = penguins['bill_depth_mm'].to_numpy()\n\ny = penguins['body_mass_g'].to_numpy()\nsmoothed = lowess(y, x, frac=0.3)  # Adjust `frac` for smoothing degree\nx_smooth = smoothed[:, 0]\ny_smooth = smoothed[:, 1]\n\nplt.scatter(x, y)\n\nplt.plot(x_smooth, y_smooth)\nplt.xlabel('Bill Depth (mm)')\nplt.ylabel('Body Mass (g)')\n\nplt.close()\n\n```\n:::\n\n\nIf we wanted to change the method we could do \n\n::: {#2241c3ae .cell execution_count=7}\n``` {.python .cell-code}\nfrom sklearn.linear_model import LinearRegression\nx_reshape = x.reshape(-1,1)\n\nmodel = LinearRegression()\n\nmodel.fit(x_reshape, y = y)\n\ny_pred = model.predict(x_reshape)\n\n\n\n\nplt.scatter(x, y, s=10, alpha=0.7, label=\"Original Data\")\nplt.plot(x, y_pred, color=\"red\", label=\"Linear Regression\")\nplt.xlabel(\"Bill Length (mm)\")\nplt.ylabel(\"Body Mass (g)\")\nplt.title(\"Linear Regression: Bill Length vs Body Mass\")\nplt.close()\n```\n:::\n\n\nSo the pattern emerges that we have some differences based on subgroups. So we need to plot these by species and then fit a regression line. In ggplot this process is a little bit more compact. But for matplot it is a lot like base R where we loop over and then do this. \n\n::: {#86795361 .cell execution_count=8}\n``` {.python .cell-code}\nspecies_unique = penguins.unique(subset='species').sort('species')['species']\n\n\n\nmarkers = ['o', 's', '^']\n\ncolors = ['red', 'blue', 'green']\n\nfor species, marker, color in zip(species_unique, markers, colors):\n    species_data = penguins.filter(pl.col('species') == species)\n    plt.scatter(x = species_data['bill_length_mm'], y = species_data['bill_depth_mm'],\n    label = species, marker = marker, color = color )\n    plt.xlabel('Bill Length (mm)')\n    plt.ylabel('Bill Depth (mm)')\n    plt.legend()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](data-viz_files/figure-html/cell-9-output-1.png){width=585 height=429}\n:::\n:::\n\n\nIn a similar way we need to do this for the the linear regression lines \n\n\n\n::: {#3ee8e27c .cell execution_count=10}\n``` {.python .cell-code}\nfor species, marker, color in zip(species_unique, markers, colors):\n    # Filter data for the current species\n    species_data = penguins.filter(pl.col('species') == species)\n\n    # Extract x and y values\n    x = species_data['bill_length_mm'].to_numpy()\n    y = species_data['bill_depth_mm'].to_numpy()\n\n    # Scatter plot\n    plt.scatter(x, y, label=species, marker=marker, color=color)\n\n    # Fit linear regression (1st-degree polynomial)\n    m, b = np.polyfit(x, y, 1)\n\n    # Plot regression line\n    plt.plot(x, m * x + b, color=color)\n\n# Add labels and legend\nplt.xlabel('Bill Length (mm)')\nplt.ylabel('Bill Depth (mm)')\nplt.legend()\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](data-viz_files/figure-html/cell-11-output-1.png){width=585 height=429}\n:::\n:::\n\n\n",
    "supporting": [
      "data-viz_files"
    ],
    "filters": [],
    "includes": {}
  }
}